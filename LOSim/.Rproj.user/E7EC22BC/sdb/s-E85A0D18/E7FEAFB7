{
    "collab_server" : "",
    "contents" : "abcCreateSummaries <- function(simulationOutput, \n                               method = \"saABC\", \n                               summarySelection = NULL, \n                               targetParameters = NULL, \n                               getSumStats,\n                               sumStats,\n                               sumStatsSampleSize,\n                               parallel = FALSE,\n                               predictionPredictor = TRUE,\n                               clusterType = \"SOCK\" # or \"MPI\"\n                               ){\n  \n  # start timing \n  ptm <- proc.time()\n  \n  # simulationOutput$info = returnInfo(simulationOutput$info, note = \"abcCreateSummaries\")\n  ssData <- getSumStats(simulations = lapply(seq_along(simulationOutput$observations),\n                                             function(x) simulationOutput$observations[[x]]$data),\n                        sampleSize = sumStatsSampleSize, \n                        sumStats = sumStats)\n  \n  if(is.null(summarySelection)) summarySelection = 1:NCOL(simulationOutput$summaries[[1]])\n  if(is.null(targetParameters)) targetParameters = 1:NCOL(simulationOutput$parameters)\n  \n  # output lists\n  simPreds <- dataPreds <- vector(\"list\", length(simulationOutput$summaries))\n  \n  # saABC: linear regression\n  if(method == \"saABC\"){\n    # predict function\n    predict <- function(summaries){\n      if(is.vector(summaries)) summaries = matrix(summaries, nrow = 1)\n      summaries[is.na(summaries)] = 0\n      summaries = cbind(summaries, summaries^2)\n      res = summaries %*% t(out$B)\n      colnames(res) = paste0(\"S\", seq_along(targetParameters))\n      return(res)\n    }\n    \n    # loop through observed individuals\n    # in parallel\n    if(parallel){\n      library(doSNOW)\n      # parallel execution\n      if(clusterType == \"MPI\"){\n        library(doMPI)\n        cl <- doMPI::startMPIcluster()\n        doMPI::registerDoMPI(cl)\n      }else{\n        if(parallel == T | parallel == \"auto\"){\n          cores <- parallel::detectCores() - 1\n          message(\"parallel, set cores automatically to \", cores)\n        }else if (is.numeric(parallel)){\n          cores <- parallel\n          message(\"parallel, set number of cores manually to \", cores)\n        }else stop(\"wrong argument to parallel\")\n        \n        cl <- parallel::makeCluster(cores, type = clusterType)\n        doSNOW::registerDoSNOW(cl)\n        \n      }  \n      \n      # set up progress bar\n      pb <- txtProgressBar(min = 1, max = length(simulationOutput$summaries), style = 3)\n      progress <- function(n) setTxtProgressBar(pb, n)\n      opts <- list(progress = progress)\n      \n      preds <- foreach::foreach(i = seq_along(simulationOutput$summaries), \n                                .packages=c(\"abctools\"), .options.snow=opts) %dopar% {\n                                  tempSum = simulationOutput$summaries[[i]]\n                                  tempSum[is.na( tempSum)] = 0\n                                  \n                                  out = abctools::saABC(theta = simulationOutput$parameters[,targetParameters], \n                                                        X = cbind(tempSum[,summarySelection], tempSum[,summarySelection]^2),\n                                                        plot = F)\n                                  \n                                  out$B[is.na(out$B) ] = 0\n                                  \n                                  \n                                  list(simPreds = predict(simulationOutput$summaries[[i]][, summarySelection]),\n                                       dataPreds = predict(ssData[[1]][i, summarySelection]))\n                        \n                                }\n      # free memory from workers\n      close(pb)\n      if(clusterType == \"MPI\"){\n        doMPI::closeCluster(cl)\n        Rmpi::mpi.finalize()\n      } else{\n        parallel::stopCluster(cl)\n      }\n      for(i in seq_along(preds)){\n        simPreds[[i]] <- preds$simPreds[[i]]\n        dataPreds[[i]] <- preds$dataPreds[[i]]\n      }\n    }else{\n      for(i in seq_along(simulationOutput$summaries)){\n        \n        tempSum = simulationOutput$summaries[[i]]\n        tempSum[is.na( tempSum)] = 0\n        \n        out = abctools::saABC(theta = simulationOutput$parameters[,targetParameters], \n                              X = cbind(tempSum[,summarySelection], tempSum[,summarySelection]^2), \n                              plot = F)\n        \n        out$B[is.na(out$B) ] = 0\n        \n        simPreds[[i]] <- predict(simulationOutput$summaries[[i]][, summarySelection])\n        dataPreds[[i]] <- predict(ssData[[1]][i, summarySelection])\n        cat(\"individual No. \",i, \"\\n\")\n      }\n    }\n  }\n    \n  \n  # ranger randomForest\n  if(method == \"rF\"){\n    library(ranger)\n    if(!parallel) parallel <- 1\n    if(parallel == TRUE) parallel <- parallel::detectCores() - 1\n    for(i in seq_along(simulationOutput$summaries)){\n      tempSum = simulationOutput$summaries[[i]]\n      tempSum[is.na( tempSum)] = 0\n      \n      rfsummaries <- vector(\"list\", length(targetParameters))\n      simRFPreds <- as.data.frame(matrix(0, ncol = length(targetParameters), \n                                         nrow = NROW(tempSum)))\n      colnames(simRFPreds) <- paste0(\"S\", seq_along(targetParameters))\n      dataRFPreds <- as.data.frame(matrix(0, ncol = length(targetParameters), \n                                          nrow = 1))\n      colnames(dataRFPreds) <- paste0(\"S\", seq_along(targetParameters))\n      \n      index = 1\n      for(j in targetParameters){\n        if(predictionPredictor){\n          TrainData <- data.frame(y = simulationOutput$parameters[,j], \n                                  tempSum[,summarySelection], \n                                  simRFPreds)\n          PredDataTrue <- as.data.frame(matrix(c(ssData[[1]][i, summarySelection],\n                                                 dataRFPreds), nrow = 1))\n        }else{\n          TrainData <- data.frame(y = simulationOutput$parameters[,j], \n                                  tempSum[,summarySelection])\n          PredDataTrue <- as.data.frame(matrix(ssData[[1]][i, summarySelection], nrow = 1))\n        }\n        \n        colnames(PredDataTrue) <- colnames(TrainData)[-1]\n        rfsummaries[[index]] <- ranger::ranger(y ~ ., data = TrainData, \n                                               num.trees = 500, write.forest = TRUE, \n                                               num.threads = parallel, verbose = FALSE)\n        \n        simRFPreds[,index] <- predict(rfsummaries[[index]], \n                                                     data = TrainData, \n                                                     num.threads = parallel)$predictions\n        dataRFPreds[,index] <- predict(rfsummaries[[index]], \n                                                      data = PredDataTrue, \n                                                      num.threads = parallel)$predictions  \n        \n        index <- index + 1\n      }\n      simPreds[[i]] <- simRFPreds\n      dataPreds[[i]] <- dataRFPreds\n      \n      cat(\"individual No. \",i, \": \", proc.time()[3] - ptm[3], \"sec.\",\"\\n\")\n    }\n  }  \n  \n  # collect results\n  output <- list()\n  output$parameters = simulationOutput$parameters\n  output$observations = simulationOutput$observations\n  #output$summarySelection$predict = predict # exports the function enviornment, clamps up disc memory\n  output$summarySelection$predictionPredictor = predictionPredictor\n  output$summarySelection$simulation = simPreds\n  output$summarySelection$observed = dataPreds\n  output$summarySelection$method = method\n  output$summarySelection$targetParameters = targetParameters\n  output$summarySelection$summarySelection = summarySelection\n  \n  \n  \n  # stop timing\n  print(proc.time() - ptm)\n  \n  return(output)\n}\n\n",
    "created" : 1504701434585.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3307656828",
    "id" : "E7FEAFB7",
    "lastKnownWriteTime" : 1502870146,
    "last_content_update" : 1502870146,
    "path" : "~/Documents/Uni/projects/littleowl/code/ABCsummaryChoice.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}