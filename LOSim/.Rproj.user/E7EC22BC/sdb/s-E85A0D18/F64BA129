{
    "collab_server" : "",
    "contents" : "# forward simulation function \n# samples parameter combinations from LOSim posterior object\nLOSim <- function(posteriorObj, \n                  habitatSuitability,\n                  individuals = NULL, \n                  startLocations, \n                  fixParameters,\n                  maxPeriod = 60, \n                  maxIterations = 40000, \n                  generations = 10,\n                  randomSeed = NULL,\n                  reflection = 20,\n                  reflectionValues = 1e-20,\n                  parallel = FALSE,\n                  clusterType = \"SOCK\" # MPI\n                  ){\n  \n  # start timing \n  ptm <- proc.time()\n  \n  library(LOSim)\n  \n  # add ring of very small values around habitatSuitability map to enable reflection\n  if(is.numeric(reflection)){\n    # add ring of reflection cells with zeros as buffer zone to enable reflection\n    rowZeros <- matrix(reflectionValues, nrow = reflection, ncol = NCOL(habitatSuitability$values))\n    colP2Zeros <- matrix(reflectionValues, nrow = NROW(habitatSuitability$values)+2*reflection, ncol = reflection)\n    #\n    habitatSuitability$values <- rbind(rowZeros, habitatSuitability$values, rowZeros)\n    habitatSuitability$values <- cbind(colP2Zeros, habitatSuitability$values, colP2Zeros)\n    \n    # edit upperleft\n    habitatSuitability$upperleft <- habitatSuitability$upperleft + c(-1,1) * reflection*habitatSuitability$resolution\n    \n  }\n  \n  \n  # number of parameter combinations per individual\n  posteriorSize <- NROW(posteriorObj$parameters[[1]])\n  # if only for a subset of individuals\n  if(!is.null(individuals) & is.numeric(individuals)) posteriorObj$parameters <- posteriorObj$parameters[individuals]\n  \n  # number of virtual individuals to create\n  n <- NROW(startLocations)\n  \n  #--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#--#\n  \n  \n  if(!parallel){\n    # initialisation\n    SimList <- vector(\"list\", generations)\n    names(SimList) <- paste0(\"generation\",1:generations)\n    # start generation loop\n    # progress bar\n    pb <- txtProgressBar(min = 0, max = generations, style = 3)\n    for(g in seq.int(generations)){\n      \n      # sample individuals\n      if(!is.null(individuals)){\n        ISample <- sample(individuals, \n                          size = n, replace = TRUE)\n      }else{\n        ISample <- sample(length(posteriorObj$parameters), \n                          size = n, replace = TRUE)\n      }\n      \n      # sample from individual specific posterior distributions\n      PSample <- t(sapply(ISample, \n                          function(x) posteriorObj$parameters[[x]][sample(posteriorSize, size = 1),]))\n      \n      #interspace with fix parameters\n      Pmat <- matrix(NA, nrow = n, \n                           ncol = 2+length(fixParameters)+length(posteriorObj$targetParameters))\n      \n      Pmat[,2+posteriorObj$targetParameters] <- PSample\n      \n      fIndex <- 1\n      for(f in seq.int(2+length(fixParameters)+\n                       length(posteriorObj$targetParameters))[-c(1,2,posteriorObj$targetParameters+2)]){\n        Pmat[,f] <- rep(fixParameters[fIndex], n)\n        fIndex <- fIndex + 1\n      }\n      \n      # first generation\n      if(g == 1){\n        # add initial start coordinates to PMat\n        Pmat[1:n,1:2] <- as.matrix(startLocations[,c(\"x\",\"y\")])\n      }else{\n        # use end coordinates of last run as start coordinates\n        Pmat[1:n,1:2] <- t(sapply(seq_along(SimList[[g-1]]), \n                                  function(x) SimList[[g-1]][[x]][NROW(SimList[[g-1]][[x]]), \n                                                                  c(\"x\", \"y\")]))\n      }\n      \n      \n  \n      SimList[[g]] <- LOSim::runSimulation(habitatSuitability$values, \n                                           maxIterations, \n                                           Pmat, \n                                           randomSeed,\n                                           \"raw\", \n                                           NULL, \n                                           maxPeriod,\n                                           habitatSuitability$upperleft,\n                                           habitatSuitability$resolution,\n                                           startTime = runif(1,0,23.9), # somewhere between 0 and 24 \n                                           startDayOfYear = sample(205:352, size = 1), # empiric take off doys\n                                           solarLatitude = round(mean(startLocations[,2])), \n                                           solarLongitude = round(mean(startLocations[,1])))[[\"simulation\"]]\n    }\n    close(pb)\n  }else{\n    library(doSNOW)\n    # parallel execution\n    if(clusterType == \"MPI\"){\n      library(doMPI)\n      cl <- doMPI::startMPIcluster()\n      cores <- cl$workerCount\n      doMPI::registerDoMPI(cl)\n    }else{\n      if(parallel == T | parallel == \"auto\"){\n        cores <- parallel::detectCores() - 1\n        message(\"parallel, set cores automatically to \", cores)\n      }else if (is.numeric(parallel)){\n        cores <- parallel\n        message(\"parallel, set number of cores manually to \", cores)\n      }else stop(\"wrong argument to parallel\")\n      \n      cl <- parallel::makeCluster(cores, type = clusterType)\n      doSNOW::registerDoSNOW(cl)\n    }\n    \n    # split parameter matrix for parallel processing\n    chunk <- function(x,n) split(x, factor(sort(rank(x)%%n)))\n    rows <- chunk(1:n, cores)\n    \n    mergeList <- function(...) {\n      mapply(c, ..., SIMPLIFY=FALSE)\n    }\n    \n    # set up progress bar\n    pb <- txtProgressBar(min = 1, max = length(rows), style = 3)\n    progress <- function(n) setTxtProgressBar(pb, n)\n    opts <- list(progress = progress)\n    \n  # simulate in parallel\n    SimList <- foreach(i = seq_along(rows), .combine = mergeList,\n                       .packages=c(\"LOSim\"), \n                       .options.snow=opts) %dopar% {\n                         prelist <- vector(\"list\", generations)\n                         names(prelist) <- paste0(\"generation\",1:generations)\n                         for(g in seq.int(generations)){\n                           # sample individuals\n                           if(!is.null(individuals)){\n                             ISample <- sample(individuals, \n                                               size = length(rows[[i]]), replace = TRUE)\n                           }else{\n                             ISample <- sample(length(posteriorObj$parameters), \n                                               size = length(rows[[i]]), replace = TRUE)\n                           }\n                           \n                           # sample from individual specific posterior distributions\n                           PSample <- t(sapply(ISample, \n                                               function(x) posteriorObj$parameters[[x]][sample(posteriorSize, size = 1),]))\n                           \n                           #interspace with fix parameters\n                           Pmat <- matrix(NA, nrow = length(rows[[i]]), \n                                          ncol = 2+length(fixParameters)+length(posteriorObj$targetParameters))\n                           \n                           Pmat[,2+posteriorObj$targetParameters] <- PSample\n                           \n                           fIndex <- 1\n                           for(f in seq.int(2+length(fixParameters)+\n                                            length(posteriorObj$targetParameters))[-c(1,2,posteriorObj$targetParameters+2)]){\n                             Pmat[,f] <- rep(fixParameters[fIndex], length(rows[[i]]))\n                             fIndex <- fIndex + 1\n                           }\n                           \n                           # first generation\n                           if(g == 1){\n                             # add initial start coordinates to PMat\n                             Pmat[,1:2] <- as.matrix(startLocations[rows[[i]],c(\"x\", \"y\")])\n                           }else{\n                             # use end coordinates of last run as start coordinates\n                             Pmat[,1:2] <- t(sapply(seq_along(prelist[[g-1]]), \n                                                       function(x) prelist[[g-1]][[x]][NROW(prelist[[g-1]][[x]]), \n                                                                                       c(\"x\", \"y\")]))\n                           }\n                           prelist[[g]] <- LOSim::runSimulation(habitatSuitability$values, \n                                                maxIterations, \n                                                Pmat, \n                                                randomSeed,\n                                                \"raw\", \n                                                NULL, \n                                                maxPeriod,\n                                                habitatSuitability$upperleft,\n                                                habitatSuitability$resolution,\n                                                startTime = runif(1,0,23.9), # somewhere between 0 and 24 \n                                                startDayOfYear = sample(205:352, size = 1), # empiric take off doys\n                                                solarLatitude = round(mean(startLocations[,2])), \n                                                solarLongitude = round(mean(startLocations[,1])))[[\"simulation\"]]\n                         }\n                         prelist\n                        }\n    \n    # close cluster\n    close(pb) # and progress bar\n    if(clusterType == \"MPI\"){\n      doMPI::closeCluster(cl)\n      Rmpi::mpi.finalize()\n    } else{\n      parallel::stopCluster(cl)\n    }\n    \n    # reorganise simList\n    \n  }\n\n  \n  res <- NULL\n  # res$parameters <- PList\n  res$simulations <- SimList\n  res$startLocations <- startLocations\n  #res$environment <- habitatSuitability\n  res$dispersalduration <- maxPeriod\n  res$individuals <- individuals\n  res$reflection$ncell <- reflection\n  res$reflection$vals <- reflectionValues\n  \n  # stop timing\n  print(proc.time() - ptm)\n  \n  return(res)\n}\n\n\n",
    "created" : 1503411673244.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "967013464",
    "id" : "F64BA129",
    "lastKnownWriteTime" : 1503663057,
    "last_content_update" : 1503775257115,
    "path" : "~/Documents/Uni/projects/littleowl/code/forwardSimulation.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}