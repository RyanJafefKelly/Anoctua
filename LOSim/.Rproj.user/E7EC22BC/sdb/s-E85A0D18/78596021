{
    "collab_server" : "",
    "contents" : "# calculate parameter estimates \ngetEstimate <- function(summaryChoice, proportionFiltered = 1/1000, parallel = FALSE, regr.adj = TRUE, comp.MAP = TRUE){\n  # start timing \n  ptm <- proc.time()\n  \n  \n  # load rcpp function to calculate distance between observed and simulated data\n  Rcpp::sourceCpp(\"../code/c++/distanceObservedSimulated.cpp\")\n  \n  numberParametersFiltered = ceiling(nrow(summaryChoice$parameters) * proportionFiltered)\n  \n  # upper and lower bounds for truncated multivariate normal distribution\n  lbounds <- apply(summaryChoice$parameters[,summaryChoice$summarySelection$targetParameters],\n                   2, min)\n  ubounds <- apply(summaryChoice$parameters[,summaryChoice$summarySelection$targetParameters],\n                   2, max)\n  \n  distances <- filtered <- pQuantiles <- pMedian <- vector(\"list\", length(summaryChoice$summarySelection$observed))\n  for(i in seq_along(summaryChoice$summarySelection$observed)){\n    \n    # standardise by range\n    reference <- unlist(diff(apply(summaryChoice$summarySelection$simulation[[i]], 2, range)))\n\n    distances[[i]] <- dObsSim(simulated = as.matrix(summaryChoice$summarySelection$simulation[[i]]),\n                              observed = unlist(summaryChoice$summarySelection$observed[[i]]),\n                              reference = reference)\n    \n    # accepted indices\n    filtered_indices <- sort(distances[[i]], method = \"quick\", \n                            index.return = TRUE)$ix[1:numberParametersFiltered]\n    \n    # accepted paramter samples\n    filtered[[i]] <- summaryChoice$parameters[filtered_indices, \n                                              summaryChoice$summarySelection$targetParameters]\n    \n    if(regr.adj){\n      # S_sim of accepted sample\n      filtered_ss <- summaryChoice$summarySelection$simulation[[i]][filtered_indices,]\n      for(c in seq(NCOL(filtered_ss))) # center around S_obs\n        filtered_ss[,c] <- filtered_ss[,c] - summaryChoice$summarySelection$observed[[i]][,c]\n      # post-sampling regression adjustment, multivariate linear model\n      psr.fm <- lm(as.formula(paste(\"filtered[[i]]~\",paste(colnames(filtered_ss), collapse = \"+\"))), \n                   data = as.data.frame(filtered_ss))$coefficients[-1,] # remove intercept\n      # correct for epsilon != 0\n      filtered[[i]] <- sapply(seq(NCOL(filtered_ss)), \n                              function(x) filtered[[i]][,x] - rowSums(t(psr.fm[,x] * t(filtered_ss))))\n      # restrict corrections to prior bounds\n      filtered[[i]] <- sapply(seq(NCOL(filtered_ss)),\n                              function(x) ifelse(filtered[[i]][,x] < lbounds[x], lbounds[x], \n                                                 ifelse(filtered[[i]][,x] > ubounds[x], ubounds[x], \n                                                        filtered[[i]][,x])))\n      colnames(filtered[[i]]) <- colnames(summaryChoice$parameters)[summaryChoice$summarySelection$targetParameters]\n    }\n\n    # posterior statistics\n    pMedian[[i]] <- apply(filtered[[i]], 2, median)\n    pQuantiles[[i]] <- apply(filtered[[i]], 2, quantile, probs = c(0.025,0.975))\n  }\n  \n  if(comp.MAP){\n    if(!parallel){\n      library(tmvtnorm)\n      pMAP <- vector(\"list\", length(summaryChoice$summarySelection$observed))\n      for(i in seq_along(summaryChoice$summarySelection$observed)){\n        pMAP[[i]] <- mle.tmvnorm(filtered[[i]], method = \"L-BFGS-B\", \n                                 lower.bounds = lbounds, \n                                 upper.bounds = ubounds)@coef[1:NCOL(filtered[[i]])]\n        pMAP[[i]] <- ifelse(pMAP[[i]] < lbounds, lbounds,\n                            ifelse(pMAP[[i]] > ubounds, ubounds,\n                                   pMAP[[i]]))\n        names(pMAP[[i]]) <- colnames(sumOut$parameters)[sumOut$summarySelection$targetParameters]\n        cat(\"individual No. \",i, \"\\n\")\n      }\n    }else{\n      # parallel execution\n      library(foreach)\n      # library(doParallel)\n      library(doSNOW)\n      \n      if(parallel == T | parallel == \"auto\"){\n        cores <- parallel::detectCores() - 1\n        message(\"parallel, set cores automatically to \", cores)\n      }else if (is.numeric(parallel)){\n        cores <- parallel\n        message(\"parallel, set number of cores manually to \", cores)\n      }else stop(\"wrong argument to parallel\")\n      \n      \n      cl <- parallel::makeCluster(cores)\n      doSNOW::registerDoSNOW(cl)\n      \n      # set up progress bar\n      pb <- txtProgressBar(min = 1, max = length(summaryChoice$summarySelection$observed), style = 3)\n      progress <- function(n) setTxtProgressBar(pb, n)\n      opts <- list(progress = progress)\n      \n      pMAP <- foreach::foreach(i = seq_along(summaryChoice$summarySelection$observed), \n                               .options.snow=opts, .packages = \"tmvtnorm\") %dopar% {\n                                 maps <- mle.tmvnorm(filtered[[i]], method = \"L-BFGS-B\",\n                                                     lower.bounds = lbounds, \n                                                     upper.bounds = ubounds)@coef[1:NCOL(filtered[[i]])]\n                                 maps <- ifelse(maps < lbounds, lbounds,\n                                                ifelse(maps > ubounds, ubounds,\n                                                       maps))\n                                 names(maps) <- colnames(sumOut$parameters)[sumOut$summarySelection$targetParameters]\n                                 maps\n                               }\n      \n      # free memory from workers\n      close(pb)\n      stopCluster(cl)\n    }\n  }  \n  \n  \n  \n  res = NULL\n  res$parameters = filtered\n  res$median = pMedian\n  if(comp.MAP) res$MAP = pMAP\n  res$quantiles = pQuantiles\n  res$targetParameters = summaryChoice$summarySelection$targetParameters\n  res$proportion = proportionFiltered\n  \n  # stop timing\n  print(proc.time() - ptm)\n  \n  return(res)\n}\n\n\n",
    "created" : 1503490443420.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3852496016",
    "id" : "78596021",
    "lastKnownWriteTime" : 1504608374,
    "last_content_update" : 1504608374517,
    "path" : "~/Documents/Uni/projects/littleowl/code/ABCgetEstimate.r",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}