# SH 07-09-2016
#
# IBM calibration
#
#-#-#-#-#-#-#-#-#-#-#

##########
# Setup  #
#--------##--------##--------##--------##--------##--------##--------##--------#
#set seed
set.seed(01022016)

# load packages
library(sp)
library(raster)
library(ranger)
library(LOSim)
library(abctools)
library(BayesianTools) 
library(lubridate)


# source functions
source("../code/CalibDataPrep.r")
source("../code/sumStats.r")
source("../code/getSumStats.r")
source("../code/createPriors.r")
source("../code/runABC.r")
source("../code/ABCsummaryChoice.r")
source("../code/plotSummariesCorrelation.r")
source("../code/ABCgetEstimate.r")
source("../code/mergeLOSim.r")

##############################
# load/prepare model input   #
#--------##--------##--------##--------##--------##--------##--------##--------#
# load telemetry data
cleaned <- read.csv("../data/natal_dispersal_cleaned.csv",
                    stringsAsFactors = FALSE)
# date as POSIXct
cleaned$date <- as.POSIXct(cleaned$date)
cleaned$date <- lubridate::with_tz(cleaned$date, "GMT")
# load IDs of training and validation set
load("../data/trainTestIDs.RData")


#----------------------------------------------------#

# classify dispersal locations # date of first outing (400m buffer)
firstOut <- 1:3
for(i in seq_along(unique(cleaned$id))){
  idIndex <- which(cleaned$id == unique(cleaned$id)[i])
  birthIndex <- idIndex[which.min(cleaned$date[cleaned$id == 
                                                 unique(cleaned$id)[i]])]
  distToBL <- sapply(idIndex, function(x) 
    sqrt((cleaned$posX[x] - cleaned$posX[birthIndex])^2
         + (cleaned$posY[x] - cleaned$posY[birthIndex])^2))
  
  search = TRUE
  j = 1
  while(search){
    if(distToBL[j] > 400){
      search = FALSE
      firstOut[i] = idIndex[j]
    }
    j = j + 1
  }
} 

firstOut <- cleaned[firstOut,]


# select locations within dispersal period, i.e. 
dispersal <- cleaned[-c(1:NROW(cleaned)),]
for(x in unique(cleaned$id)){
  subs <-  cleaned[cleaned$id == x 
                   & cleaned$date >= firstOut$date[firstOut$id == x] 
                   & cleaned$date <= (firstOut$date[firstOut$id == x] + 3600*24*60),]
  dispersal <- rbind(dispersal, subs)
}
rm(search, x, j, i, idIndex, distToBL, birthIndex, subs)

# # spatialpointsdataframe
dispSpdf <- SpatialPointsDataFrame(coords = dispersal[,c("posX","posY")], 
                                   data = dispersal) 
# add correct projection: DHDN / Gauss-Kruger zone 3
proj4string(dispSpdf) <- CRS("+init=epsg:31467")

#----------------------------------------------------#
# get start points from dispersal data, i.e. first recorded locations in dispersal period
startIndex <- 1:3
for(i in seq_along(unique(dispSpdf$id))){
  idIndex <- which(dispSpdf$id == unique(dispSpdf$id)[i])
  startIndex[i] <- idIndex[which(dispSpdf$date[idIndex] == min(dispSpdf$date[idIndex]))]
} 
startPoints <- dispSpdf[startIndex, ]

# telemetry data extent + 50 km buffer
calibrationExtent <- extent(startPoints) + rep(c(-40000,40000), 2)

#----------------------------------------------------#
# load habitat suitability
habitatSuitability <- raster("../envVars/envOnStudyExtent/habitatSuitabilityScaled.tif")
# habitatSuitability <- raster("../envVars/JF/S123_bins.tif")
# proj4string(habitatSuitability) <- CRS("+init=epsg:31467")
# crop habitat suitability map
habSuitCalib <- crop(habitatSuitability, calibrationExtent)
habSuitCalib[is.na(values(habSuitCalib))] <- 0 # set NAs to zero <- reflection
HSvals <- as.matrix(habSuitCalib)

#----------------------------------------------------#
# priors for observation error
Accuracy <- sapply(unique(dispSpdf$id), function(x) dispersal$accuracy[dispersal$id == x])
accLookUp <- c(0,5,20,50,100,200)
AccMetric <- sapply(unique(dispSpdf$id), function(x) accLookUp[Accuracy[[x]]+1])
AccMetric <- unlist(AccMetric)

#----------------------------------------------------#
# prepare telemetry data
rscRange = 200
calibrationData <- calibTransform(x = dispersal$posX, y = dispersal$posY,
                                  date = dispersal$date, id = dispersal$id,
                                  habitatSuitability = habSuitCalib, rscExtent = rscRange)

# filter individuals with more than 50 recorded locations
nRelocs <- sapply(seq_along(calibrationData), function(x) NROW(calibrationData[[x]]$data))
calibID <- names(calibrationData)[nRelocs  > 50 & names(calibrationData) %in% trainingID]
validID <- names(calibrationData)[nRelocs  > 50 & names(calibrationData) %in% testID]

#save(calibID,validID, file = "../data/trainTestIDs_g50rl.RData")

####################
# parameter sample #
#--------##--------##--------##--------##--------##--------##--------##--------#
# number of simulations per individual
n = 500000

# parameter names
pnames <- c("habitatPreference", 
            "stepShape", 
            "stepScale", 
            "directionalBias", 
            "dispRestMean", 
            "dispRestSd", 
            "maximumEffort", 
            "roostLambda",
            "observationError",
            "rscRange")

# prior distributions
distr <- list(runif, runif, NULL, runif, NULL, NULL, NULL, runif, rnorm, NULL)

# prior ranges
ranges <- list(c(0.1, 5), 
               c(0.1, 4), 
               2, 
               c(0.1, 3.5), 
               1.5,  
               0.7, 
               6000,
               c(.01,30),
               c(mean(AccMetric),sd(AccMetric)),
               rscRange
)

# which parameters are fixed
fixed = c(3,5,6,7,10)

# create parameters
Ps <- createPriors(pnames, distr, ranges, n, redraw = 9, fixed)

# careful: throw away first x in y. run, throw away first 30 000 (r.seed issue)
# Ps <- Ps[500001:1000000,]
####################
# model setup      #
#--------##--------##--------##--------##--------##--------##--------##--------#

# environment input
HS <- list(values = HSvals, upperleft = extent(habSuitCalib)[c(1,4)], resolution = raster::res(habSuitCalib)[1])

simulation <- runABC(Ps, HS, calibrationData[calibID], parallel = TRUE, 
                      maxIterations = 40000, randomSeed = NULL, 
                      sumStatsSampleSize = 5000, sumStats, getSumStats)


# save(simulation, file = "../data/simulation.RData")
# load("../data/simulation.RData")
# load("../data/simulation01.RData")
# load("../data/simulation02.RData")


# merge simulations
# simulation <- mergeLOSim(simulation01, simulation02)
# save(simulation, file = "../data/simulation.RData")
# load("../data/simulation.RData")

# selected summary estimation
summaries <- abcCreateSummaries(simulation, method = "rF", summarySelection = NULL, 
                                  targetParameters = c(1,2,4,8), getSumStats = getSumStats, 
                                  sumStats = sumStats, sumStatsSampleSize = 5000, parallel = TRUE,
                                  predictionPredictor = TRUE)
# save(summaries, file = "../data/summaries.RData")
# load("../data/summaries.RData")


# rejection
posterior <- getEstimate(summaries, proportionFiltered = 1/500, parallel = FALSE, regr.adj = TRUE, comp.MAP = FALSE)
# save(posterior, file = "../data/posterior.RData")
# load("../data/posterior.RData")


# plot posterior distributions
addInfo <- read.csv("../data/Additional_data_juveniles.csv")

# load calibration IDs
load("../data/trainTestIDs_g50rl.RData")
# use only calibID information
addInfo <- addInfo[addInfo$Name1 %in% calibID,]

# pool by Sex

# habitat preference
fHP <- unlist(lapply(which(addInfo$Sex == "f"), function(x) posterior$parameters[[x]][,1])); mean(fHP)
mHP <- unlist(lapply(which(addInfo$Sex == "m"), function(x) posterior$parameters[[x]][,1])); mean(mHP)
# t.test(fHP,mHP)

# step shape
fSS <- unlist(lapply(which(addInfo$Sex == "f"), function(x) posterior$parameters[[x]][,2])); mean(fSS)
mSS <- unlist(lapply(which(addInfo$Sex == "m"), function(x) posterior$parameters[[x]][,2])); mean(mSS)
# t.test(fSS,mSS)

# directional bias
fDB <- unlist(lapply(which(addInfo$Sex == "f"), function(x) posterior$parameters[[x]][,3])); mean(fDB)
mDB <- unlist(lapply(which(addInfo$Sex == "m"), function(x) posterior$parameters[[x]][,3])); mean(mDB)
# t.test(fDB,mDB)

# maximum effort
fME <- unlist(lapply(which(addInfo$Sex == "f"), function(x) posterior$parameters[[x]][,4])); mean(fME)
mME <- unlist(lapply(which(addInfo$Sex == "m"), function(x) posterior$parameters[[x]][,4])); mean(mME)
# t.test(fME,mME)

# plot posterior distributions
pdf("../figures/posterior.pdf", width = 10, height = 10)
par(mfrow=c(2,2), mar=c(1.5,.5,.5,0), oma=c(0,0,0,1), cex.lab = 1.5, cex.axis = 1.3, las = 1, mgp = c(1.5,0.4,0), tcl = -0.2, pty = "s")
plot(density(posterior$parameters[[1]][,1]), xlim=c(0.1,5), 
     main = "", xlab = "", ylab = "", 
     ylim =c(0,2.8), type = "n", yaxt = "n",lwd=0.5)
for(i in 1:length(posterior$parameters)) 
  lines(density(posterior$parameters[[i]][,1]), col = ifelse(is.na(addInfo$Sex[i]),
                                                                rgb(0.7,0.7,0.7),
                                                                ifelse(addInfo$Sex[i] == "f",
                                                                       rgb(0.55,0,0,0.4),
                                                                       rgb(0,0,0.55,0.4))),
        lwd=0.5)
# pooled
lines(density(fHP), col = rgb(0.55,0,0), lwd=2) 
lines(density(mHP), col = rgb(0,0,0.55), lwd=2)

plot(density(posterior$parameters[[1]][,2]), xlim=c(0.1,4), 
     main = "", xlab = "", ylab = "", 
     ylim =c(0,3.6), type = "n", yaxt = "n",lwd=0.5)
for(i in 1:length(posterior$parameters)) 
  lines(density(posterior$parameters[[i]][,2]), col = ifelse(is.na(addInfo$Sex[i]),
                                                                rgb(0,0,0,0.4),
                                                                ifelse(addInfo$Sex[i] == "f",
                                                                       rgb(0.55,0,0,0.4),
                                                                       rgb(0,0,0.55,0.4))),
        lwd=0.5)
# pooled
lines(density(fSS), col = rgb(0.55,0,0), lwd=2) 
lines(density(mSS), col = rgb(0,0,0.55), lwd=2)

plot(density(posterior$parameters[[1]][,3]), xlim=c(0.1,3.5), 
     main = "", xlab = "", ylab = "",
     ylim =c(0,4.1), type = "n", yaxt = "n",lwd=0.5)
for(i in 1:length(posterior$parameters)) 
  lines(density(posterior$parameters[[i]][,3]), col = ifelse(is.na(addInfo$Sex[i]),
                                                                rgb(0,0,0,0.4),
                                                                ifelse(addInfo$Sex[i] == "f",
                                                                       rgb(0.55,0,0,0.4),
                                                                       rgb(0,0,0.55,0.4))),
        lwd=0.5)
# pooled
lines(density(fDB), col = rgb(0.55,0,0), lwd=2) 
lines(density(mDB), col = rgb(0,0,0.55), lwd=2)

plot(density(posterior$parameters[[1]][,4]), xlim=c(0.01,30), 
     main = "", xlab = "", ylab = "",
     ylim =c(0,0.9), type = "n", yaxt = "n",lwd=0.5)
for(i in 1:length(posterior$parameters)) 
  lines(density(posterior$parameters[[i]][,4]), col = ifelse(is.na(addInfo$Sex[i]),
                                                                rgb(0,0,0,0.4),
                                                                ifelse(addInfo$Sex[i] == "f",
                                                                       rgb(0.55,0,0,0.4),
                                                                       rgb(0,0,0.55,0.4))),
        lwd=0.5)
# pooled
lines(density(fME), col = rgb(0.55,0,0), lwd=2) 
lines(density(mME), col = rgb(0,0,0.55), lwd=2)

dev.off()

# x11(10,10)
# par(mfrow=c(2,2), pty = "s")
# plot(density(posterior$parameters[[1]][,1]), xlim=c(0.1,5), 
#      main = "habitat preference", xlab = "par value", 
#      ylim =c(0,3), col = rgb(0,0,0,0.2))
# for(i in 2:length(posterior$parameters)) 
#   lines(density(posterior$parameters[[i]][,1]), col = rgb(0,0,0,0.2))
# plot(density(posterior$parameters[[1]][,2]), xlim=c(0.1,4), 
#      main = "step shape", xlab = "par value", 
#      ylim =c(0,3), col = rgb(0,0,0,0.2))
# for(i in 2:length(posterior$parameters)) 
#   lines(density(posterior$parameters[[i]][,2]), col = rgb(0,0,0,0.2))
# plot(density(posterior$parameters[[1]][,3]), xlim=c(0.1,2), 
#      main = "directional bias", xlab = "par value", 
#      ylim =c(0,3), col = rgb(0,0,0,0.2))
# for(i in 2:length(posterior$parameters)) 
#   lines(density(posterior$parameters[[i]][,3]), col = rgb(0,0,0,0.2))
# plot(density(posterior$parameters[[1]][,4]), xlim=c(2000,12000), 
#      main = "maximum effort", xlab = "par value", 
#      ylim =c(0,0.001), col = rgb(0,0,0,0.2))
# for(i in 2:length(posterior$parameters)) 
#   lines(density(posterior$parameters[[i]][,4]), col = rgb(0,0,0,0.2))

#--------##--------##--------##--------##--------##--------##--------##--------#
x11(10,10)
correlationPlot(posterior$parameters[[1]], density = "smooth")
png("../figures/results/summaries_rf_corPlot.png", width = 500, height = 500, units = "px")
plotSC(summaries, plot.which = 1)
dev.off()

#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
# estimate summary statistics using partial least squre regression

# load("../data/simulation.RData")
# 
# # selected summary estimation
# plsr_ssEstimates <- abcCreateSummaries(simulation, method = "saABC", summarySelection = NULL, 
#                                        targetParameters = c(1,2,4,8), getSumStats = getSumStats, 
#                                        sumStats = sumStats, sumStatsSampleSize = 5000, nCPU = NULL,
#                                        predictionPredictor = FALSE)

# save(plsr_ssEstimates, file = "../data/plsrEstimates.RData")

#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#
#--------##--------##--------##--------##--------##--------##--------##--------#